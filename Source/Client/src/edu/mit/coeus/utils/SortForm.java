/*
 * SortForm.java
 *
 * Created on July 19, 2004, 10:26 AM
 */
/*
 * Copyright (c) Massachusetts Institute of Technology
 * 77 Massachusetts Avenue, Cambridge, MA 02139-4307
 * All rights reserved.
 * SortForm.java
 *
 */
package edu.mit.coeus.utils;

/**
 *
 * @author  nadhgj
 */

import java.util.Vector;
import java.awt.*;
import java.awt.event.*;
import javax.swing.JTable;

import edu.mit.coeus.gui.*;
import edu.mit.coeus.utils.CoeusGuiConstants;
import edu.mit.coeus.utils.table.*;
import edu.mit.coeus.utils.EmptyHeaderRenderer;
import edu.mit.coeus.utils.ScreenFocusTraversalPolicy;
import java.awt.event.ItemListener;
import java.awt.event.MouseListener;
import java.util.Hashtable;
import javax.swing.AbstractAction;
import javax.swing.AbstractCellEditor;
import javax.swing.JCheckBox;
import javax.swing.JLabel;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.TableCellEditor;
import javax.swing.table.TableColumn;

public class SortForm extends javax.swing.JPanel implements ActionListener{
    
    private static final String EMPTY_STRING = "";
    private JTable table;
    
    private Class[] colTypes = {String.class,Boolean.class};
    private String[] colNames = {""};
    
    public static final int OK_CLICKED = 0;
    public static final int CANCEL_CLICKED = 1;
    
    private int clicked = CANCEL_CLICKED;
    
    private static final int SORT_COLUMN = 0;
    private static final int ASC_COLUMN = 1;
    
    /*width of the hierarchy list form*/
    private static final int WIDTH = 420;
    
    /*height of the hierarchy list form*/
    private static final int HEIGHT = 220;
    
    private String title = "Sort";
    
    private CoeusDlgWindow sortDlgWindow;
    
    
    private int[] sortColumns;
    
    private int[] ascending;
    
    private CoeusDlgWindow dlgCustomize;
    
    protected String[] strAll;
    
    private Vector vecAvailbleCols;
    
    protected String[] strSortedcols;
    
    private Vector vecSortedcols;
    
    private Vector vecSortData;
    
    private CoeusAppletMDIForm mdiForm = CoeusGuiConstants.getMDIForm();
    
    private ColumnEditor columnEditor;
    
    private ColumnRenderer columnRenderer;
    
    private CustomizeTableModel ctmTableModel;
    
    /** Creates new form SortForm */
    public SortForm(JTable table,Vector sortedCols) {
        this.table = table;
        this.vecSortData = sortedCols;
        initComponents();
        postInitComponents();
        registerComponents();
        setColumnData();
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    private void initComponents() {//GEN-BEGIN:initComponents
        java.awt.GridBagConstraints gridBagConstraints;

        scrAvialableColumns = new javax.swing.JScrollPane();
        tblAvailablecolumns = new edu.mit.coeus.utils.table.CoeusDnDTable();
        scrSortColumns = new javax.swing.JScrollPane();
        tblSortColumns = new edu.mit.coeus.utils.table.CoeusDnDTable();
        lblAvailableColumns = new javax.swing.JLabel();
        lblSortColumns = new javax.swing.JLabel();
        lblAscending = new javax.swing.JLabel();
        pnlButton = new javax.swing.JPanel();
        btnOk = new javax.swing.JButton();
        btnCancel = new javax.swing.JButton();

        setLayout(new java.awt.GridBagLayout());

        setPreferredSize(new java.awt.Dimension(500, 300));
        scrAvialableColumns.setBackground(java.awt.Color.white);
        scrAvialableColumns.setMinimumSize(new java.awt.Dimension(165, 125));
        scrAvialableColumns.setPreferredSize(new java.awt.Dimension(165, 125));
        tblAvailablecolumns.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {},
                {},
                {},
                {}
            },
            new String [] {

            }
        ));
        scrAvialableColumns.setViewportView(tblAvailablecolumns);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(3, 3, 0, 0);
        add(scrAvialableColumns, gridBagConstraints);

        scrSortColumns.setBackground(java.awt.Color.white);
        scrSortColumns.setMinimumSize(new java.awt.Dimension(180, 125));
        scrSortColumns.setPreferredSize(new java.awt.Dimension(190, 125));
        tblSortColumns.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {},
                {},
                {},
                {}
            },
            new String [] {

            }
        ));
        scrSortColumns.setViewportView(tblSortColumns);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.gridwidth = 3;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHEAST;
        gridBagConstraints.insets = new java.awt.Insets(3, 7, 0, 0);
        add(scrSortColumns, gridBagConstraints);

        lblAvailableColumns.setFont(CoeusFontFactory.getLabelFont());
        lblAvailableColumns.setText("Columns Available for Sorting");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 0);
        add(lblAvailableColumns, gridBagConstraints);

        lblSortColumns.setFont(CoeusFontFactory.getLabelFont());
        lblSortColumns.setText("Sort Columns");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(0, 11, 0, 0);
        add(lblSortColumns, gridBagConstraints);

        lblAscending.setFont(CoeusFontFactory.getLabelFont());
        lblAscending.setText("Ascending");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 3;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHEAST;
        gridBagConstraints.insets = new java.awt.Insets(0, 10, 0, 0);
        add(lblAscending, gridBagConstraints);

        pnlButton.setLayout(new java.awt.GridBagLayout());

        btnOk.setFont(CoeusFontFactory.getLabelFont());
        btnOk.setMnemonic('O');
        btnOk.setText("OK");
        btnOk.setMinimumSize(new java.awt.Dimension(73, 25));
        btnOk.setPreferredSize(new java.awt.Dimension(73, 25));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHEAST;
        gridBagConstraints.insets = new java.awt.Insets(3, 4, 0, 0);
        pnlButton.add(btnOk, gridBagConstraints);

        btnCancel.setFont(CoeusFontFactory.getLabelFont());
        btnCancel.setMnemonic('C');
        btnCancel.setText("Cancel");
        btnCancel.setMaximumSize(new java.awt.Dimension(73, 25));
        btnCancel.setMinimumSize(new java.awt.Dimension(73, 25));
        btnCancel.setPreferredSize(new java.awt.Dimension(73, 25));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 3;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(3, 4, 0, 0);
        pnlButton.add(btnCancel, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.gridwidth = 3;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHEAST;
        gridBagConstraints.insets = new java.awt.Insets(0, 7, 0, 0);
        add(pnlButton, gridBagConstraints);

    }//GEN-END:initComponents
    
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    public javax.swing.JButton btnCancel;
    public javax.swing.JButton btnOk;
    public javax.swing.JLabel lblAscending;
    public javax.swing.JLabel lblAvailableColumns;
    public javax.swing.JLabel lblSortColumns;
    public javax.swing.JPanel pnlButton;
    public javax.swing.JScrollPane scrAvialableColumns;
    public javax.swing.JScrollPane scrSortColumns;
    public edu.mit.coeus.utils.table.CoeusDnDTable tblAvailablecolumns;
    public edu.mit.coeus.utils.table.CoeusDnDTable tblSortColumns;
    // End of variables declaration//GEN-END:variables
    
    public static void main(String s[]) {
        //        SortForm sortForm = new SortForm();
        //        int sel = cutomizeRepReq.display();
        //        if(sel == OK_CLICKED) {
        //            //System.out.println("OK");
        //        }else if(sel == CANCEL_CLICKED){
        //            //System.out.println("Cancel");
        //        }
        
    }
    
    protected void postInitComponents() {
        this.vecSortedcols = getTableData(vecSortData);
        columnEditor = new ColumnEditor();
        columnRenderer = new ColumnRenderer();
        sortDlgWindow = new CoeusDlgWindow(mdiForm,true);
        sortDlgWindow.setResizable(false);
        sortDlgWindow.getContentPane().add(this);
        sortDlgWindow.setTitle("Sort");
        sortDlgWindow.setFont(CoeusFontFactory.getLabelFont());
        sortDlgWindow.setDefaultCloseOperation(CoeusDlgWindow.DO_NOTHING_ON_CLOSE);
        sortDlgWindow.setSize(WIDTH, HEIGHT);
        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
        Dimension dlgSize = sortDlgWindow.getSize();
        sortDlgWindow.setLocation(screenSize.width/2 - (dlgSize.width/2),
        screenSize.height/2 - (dlgSize.height/2));
        
        sortDlgWindow.addEscapeKeyListener(
        new AbstractAction("escPressed"){
            public void actionPerformed(ActionEvent actionEvent){
                sortDlgWindow.dispose();
            }
        });
        sortDlgWindow.addWindowListener(new WindowAdapter(){
            public void windowClosing(WindowEvent we){
                sortDlgWindow.dispose();
            }
        });
        
        sortDlgWindow.addComponentListener(
        new ComponentAdapter(){
            public void componentShown(ComponentEvent e){
                setWindowFocus();
            }
        });
        
        setUpTable(tblAvailablecolumns, vecAvailbleCols);
        tblAvailablecolumns.setColumnVisibility(1, false);
        
        setUpTable(tblSortColumns, vecSortedcols);
        tblSortColumns.getColumnModel().getColumn(ASC_COLUMN).setCellEditor(new ColumnEditor());
    }
    
    private void setWindowFocus(){
        btnCancel.requestFocusInWindow();
    }
    
    private void setColumnData() {
        
        TableColumn column = tblSortColumns.getColumnModel().getColumn(ASC_COLUMN);
        column.setCellEditor(new ColumnEditor());
        column.setCellRenderer(columnRenderer);
        column = tblSortColumns.getColumnModel().getColumn(SORT_COLUMN);
        //        column.setPreferredWidth(120);
        column.setPreferredWidth(160);
    }
    
    private void registerComponents() {
        btnOk.addActionListener(this);
        btnCancel.addActionListener(this);
        
        Component[] component = {btnOk,btnCancel};
        ScreenFocusTraversalPolicy policy = new ScreenFocusTraversalPolicy(component);
        setFocusTraversalPolicy(policy);
        setFocusCycleRoot(true);
    }
    
    private void setUpTable(JTable jTable, Vector data) {
        //        Vector vecData = prepareDataVector(data);
        
        ctmTableModel = new CustomizeTableModel(data, colNames, colTypes);
        jTable.setModel(ctmTableModel);
        
        jTable.setShowHorizontalLines(false);
        jTable.setShowVerticalLines(false);
        
        jTable.getTableHeader().setDefaultRenderer(new EmptyHeaderRenderer());
        
        jTable.setForeground(Color.black);
        jTable.setBackground(Color.white);
        
    }
    
    private Hashtable prepareSortedColVector(Vector vecData) {
        Hashtable colNames = new Hashtable();
        for(int idx=0; idx<vecData.size(); idx++)
            colNames.put(((Vector)vecData.get(idx)).get(0),((Vector)vecData.get(idx)).get(2));
        return colNames;
    }
    
    private Vector getTableData(Vector sortedCols) {
        int colCount = table.getColumnCount();
        vecAvailbleCols = new Vector();
        strAll = new String[colCount];
        strSortedcols = new String[sortedCols.size()];
        Vector data = null;
        vecSortedcols = new Vector();
        int index =0;
        int sortedColInx = 0;
        Hashtable htColNames = prepareSortedColVector(sortedCols);
        for(int colNameIdx=0; colNameIdx<colCount; colNameIdx++) {
            if(table.getColumnModel().getColumn(colNameIdx).getPreferredWidth() != 0) {
                data = new Vector();
                //modified for not displaying the column names in the table which holds an Hand Icon start 
                String colName = table.getColumnName(colNameIdx);
                if(!colName.trim().equals("")) {
                    strAll[index] = colName;//table.getColumnName(colNameIdx);
                    //End modification for not displaying the column names in the table
                    if(sortedCols==null || !htColNames.containsKey(table.getColumnName(colNameIdx))) {
                        data.addElement(table.getColumnName(colNameIdx));
                        data.addElement(new Boolean(true));
                        vecAvailbleCols.add(data);
                    }
                    else {
                        data.addElement(table.getColumnName(colNameIdx));
                        data.addElement(htColNames.get(table.getColumnName(colNameIdx)));
                        vecSortedcols.add(data);
                        strSortedcols[sortedColInx++] = table.getColumnName(colNameIdx);
                    }
                }
            }
            index++;
        }
        return vecSortedcols;
    }
    
    /**
     *prepares Vector of Vectors from the String array to be displayed in the table
     */
    private Vector prepareDataVector(String data[]) {
        Vector vecTemp;
        Vector vecData = new Vector();
        
        for(int index = 0; index < data.length; index++) {
            vecTemp = new Vector();
            vecTemp.add(data[index]);
            vecData.add(vecTemp);
        }
        
        return vecData;
    }
    
    /**
     * Displays the dialog
     */
    public Vector display() {
        sortDlgWindow.show();
        Vector vecResultData = new Vector();
        vecResultData.addElement(new Integer(clicked));
        vecResultData.addElement(vecSortData);
        return vecResultData;
    }
    
    /**
     * Invoked when an action occurs.
     */
    public void actionPerformed(ActionEvent actionEvent) {
        
        Object source = actionEvent.getSource();
        if(source.equals(btnOk)) {
            clicked = OK_CLICKED;
            columnEditor.stopCellEditing();
            //Prepare int array which the caller will use.
            sortColumns = prepareIndices(tblSortColumns);
            sortDlgWindow.dispose();
            
        }else if(source.equals(btnCancel)) {
            clicked = CANCEL_CLICKED;
            sortDlgWindow.dispose();
        }
        
    }//End Action Performed
    
    private int[] prepareIndices(JTable jTable) {
        int[] retVal = new int[jTable.getRowCount()];
        vecSortData = new Vector();
        String value;
        Vector newData = null;
        for(int tblIndex = 0; tblIndex < retVal.length; tblIndex++) {
            newData = new Vector();
            value = jTable.getValueAt(tblIndex, 0).toString();
            for(int index = 0; index < strAll.length; index++) {
                if(value.equals(strAll[index])) {
                    retVal[tblIndex] = index;
                    newData.addElement(value);
                    newData.addElement(new Integer(index));
                    newData.addElement((Boolean)jTable.getValueAt(tblIndex, 1));
                    break;
                }
            }//End for All
            vecSortData.add(newData);
        }//End for group
        return retVal;
    }
    
    public int[] getSortColumns() {
        return sortColumns;
    }
    
    public void setTitle(String title) {
        this.title = title;
    }
    
    /**
     * Setter for property strAll.
     * @param strAll New value of property strAll.
     */
    public void setColumns(String[] strAll) {
        this.strAll = strAll;
    }
    
    
    /**
     * Setter for property strSortedcols.
     * @param strSortedcols New value of property strSortedcols.
     */
    public void setSortedColumns(String[] strSortedcols) {
        this.strSortedcols = strSortedcols;
    }
    
    class ColumnEditor extends AbstractCellEditor implements TableCellEditor,ItemListener{
        private JLabel lblModule;
        private JCheckBox chkRequired;
        private int row;
        int column;
        public ColumnEditor() {
            lblModule = new JLabel();
            chkRequired = new JCheckBox();
            chkRequired.addItemListener(this);
            chkRequired.setHorizontalAlignment(JCheckBox.CENTER);
        }
        /**
         *This method is to get the table cell editor component
         * @param JTable table
         * @param Object value
         * @param boolean isSelected
         * @param int row
         * @param int column
         * @return Component
         */
        public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column) {
            this.column = column;
            this.row = row;
            switch(column) {
                case 1 :
                    chkRequired.setSelected(((Boolean)value).booleanValue());
                    ctmTableModel.fireTableDataChanged();
                    return chkRequired;
            }
            return chkRequired;
        }
        
        public Object getCellEditorValue() {
            switch(column) {
                case 0:
                    return lblModule.getText();
                case 1:
                    return new Boolean(chkRequired.isSelected());
            }
            return chkRequired;
        }
        
        public void itemStateChanged(ItemEvent itemEvent ) {
            this.stopCellEditing();
        }
    }
    
    class ColumnRenderer extends DefaultTableCellRenderer {
        private JLabel lblModule;
        private JCheckBox chkRequired;
        
        int column;
        public ColumnRenderer() {
            lblModule = new JLabel();
            chkRequired = new JCheckBox();
            chkRequired.setHorizontalAlignment(JCheckBox.CENTER);
            
        }
        /**
         *This method is to get the table cell editor component
         * @param JTable table
         * @param Object value
         * @param boolean isSelected
         * @param int row
         * @param int column
         * @return Component
         */
        public Component getTableCellRendererComponent(JTable table, Object value,
        boolean isSelected, boolean hasFocus, int row, int column) {
            this.column = column;
            switch(column) {
                case 1 :
                    chkRequired.setSelected(((Boolean)value).booleanValue());
                    if(isSelected )
                        chkRequired.setBackground(table.getSelectionBackground());
                    else
                        chkRequired.setBackground(java.awt.Color.WHITE);
                    return chkRequired;
            }
            return chkRequired;
        }
    }
    
    class CustomizeTableModel extends CoeusTableModel {
        CustomizeTableModel(Vector data, String colNames[], Class colTypes[]){
            super(data, colNames, colTypes);
        }
        
        public String getColumnName(int column) {
            return null;
        }
        
        public void addRow(Vector rowData) {
            Object dataToAdd = rowData.get(0);
            int size = dataVector.size();
            Vector data;
            for(int index = 0; index < size; index++){
                data = (Vector)dataVector.get(index);
                if(data.contains(dataToAdd)) {
                    return ;
                }
            }
            
            super.addRow(rowData);
        }
        
        /**
         *This method is to set the value with respect to the row and column
         *@param Object value
         *@param int row
         *@param int col
         *@return void
         */
        public void setValueAt(Object value, int row, int col) {
            Vector vecRow = (Vector)dataVector.get(row);
            if(col == 1) {
                vecRow.remove(col);
                vecRow.addElement((Boolean)value);
                columnEditor.stopCellEditing();
            }
        }
        
        public Object getValueAt(int row, int column) {
            //System.out.println("Value @ "+row+" : "+column);
            return ((Vector)dataVector.get(row)).get(column);
        }
        
        public boolean isCellEditable(int row, int column) {
            return column==1 ? true : false;
        }
        
        public void setData(Vector data) {
            dataVector = data;
        }
        
        public int getRowCount(){
            if(dataVector==null){
                return 0;
            }else{
                return dataVector.size();
            }
        }
        
    }
}

